"""
Module de d√©tection de vuln√©rabilit√©s avec Nmap NSE Scripts
"""

import subprocess
import xml.etree.ElementTree as ET
import logging
import shutil
from typing import List, Dict, Optional

logger = logging.getLogger(__name__)


def check_nmap_installed() -> bool:
    """
    V√©rifie si Nmap est install√© sur le syst√®me

    Returns:
        True si Nmap est install√©, False sinon
    """
    return shutil.which("nmap") is not None


def scan_vulnerabilities_nmap(ip: str, ports: List[int] = None, timeout: int = 300) -> Dict:
    """
    Scanne les vuln√©rabilit√©s d'un h√¥te avec Nmap NSE Scripts

    Args:
        ip: Adresse IP √† scanner
        ports: Liste des ports √† scanner (optionnel, scanne les ports ouverts)
        timeout: Timeout en secondes (par d√©faut 5 minutes)

    Returns:
        Dictionnaire avec les vuln√©rabilit√©s trouv√©es
    """
    if not check_nmap_installed():
        logger.error("Nmap n'est pas install√© sur le syst√®me")
        return {
            'ip': ip,
            'error': 'Nmap non install√©',
            'vulnerabilities': []
        }

    result = {
        'ip': ip,
        'vulnerabilities': [],
        'scan_time': 0,
        'error': None
    }

    try:
        # Construire la commande Nmap
        # Scripts NSE pour vuln√©rabilit√©s:
        # - vulners: Base de donn√©es Vulners (n√©cessite --script-args mincvss=5.0)
        # - vuln: Cat√©gorie de scripts de d√©tection de vuln√©rabilit√©s
        # - vulscan: Si install√© (base de donn√©es locale)

        nmap_cmd = [
            'nmap',
            '-sV',  # D√©tection de version
            '--script', 'vulners,vuln',  # Scripts de vuln√©rabilit√©s
            '--script-args', 'mincvss=5.0',  # CVSS minimum 5.0 (Moyen √† Critique)
            '-oX', '-',  # Output XML sur stdout
        ]

        # Ajouter les ports si sp√©cifi√©s
        if ports:
            port_list = ','.join(map(str, ports))
            nmap_cmd.extend(['-p', port_list])
        else:
            # Scanner les ports les plus communs si non sp√©cifi√©s
            nmap_cmd.append('--top-ports=1000')

        # Ajouter l'IP
        nmap_cmd.append(ip)

        logger.info(f"Lancement scan Nmap: {' '.join(nmap_cmd)}")

        # Ex√©cuter Nmap
        process = subprocess.run(
            nmap_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=timeout,
            text=True
        )

        if process.returncode != 0:
            logger.error(f"Erreur Nmap: {process.stderr}")
            result['error'] = f"Erreur Nmap: {process.stderr[:200]}"
            return result

        # Parser le XML
        vulnerabilities = parse_nmap_xml(process.stdout)
        result['vulnerabilities'] = vulnerabilities

        logger.info(f"Scan termin√© pour {ip}: {len(vulnerabilities)} vuln√©rabilit√©(s) trouv√©e(s)")

    except subprocess.TimeoutExpired:
        logger.error(f"Timeout lors du scan de {ip}")
        result['error'] = f"Timeout ({timeout}s)"
    except Exception as e:
        logger.error(f"Erreur lors du scan de {ip}: {e}")
        result['error'] = str(e)

    return result


def parse_nmap_xml(xml_output: str) -> List[Dict]:
    """
    Parse la sortie XML de Nmap pour extraire les vuln√©rabilit√©s

    Args:
        xml_output: Sortie XML de Nmap

    Returns:
        Liste de vuln√©rabilit√©s
    """
    vulnerabilities = []

    try:
        root = ET.fromstring(xml_output)

        # Parcourir les h√¥tes
        for host in root.findall('.//host'):
            # Parcourir les ports
            for port in host.findall('.//port'):
                port_id = port.get('portid')
                protocol = port.get('protocol')

                # R√©cup√©rer le service
                service = port.find('service')
                service_name = service.get('name', 'unknown') if service is not None else 'unknown'
                service_version = service.get('version', '') if service is not None else ''

                # Parcourir les scripts
                for script in port.findall('.//script'):
                    script_id = script.get('id')
                    script_output = script.get('output', '')

                    # Parser les vuln√©rabilit√©s selon le script
                    if script_id == 'vulners':
                        # Script Vulners - format: CVE-XXXX-XXXX   score  description
                        vulns = parse_vulners_output(script_output, port_id, service_name, service_version)
                        vulnerabilities.extend(vulns)

                    elif script_id.startswith('vuln') or 'vuln' in script_id:
                        # Scripts vuln-* (http-vuln-*, smb-vuln-*, etc.)
                        vuln = parse_vuln_script_output(script_id, script_output, port_id, service_name)
                        if vuln:
                            vulnerabilities.append(vuln)

        # D√©dupliquer les vuln√©rabilit√©s
        vulnerabilities = deduplicate_vulnerabilities(vulnerabilities)

    except ET.ParseError as e:
        logger.error(f"Erreur parsing XML: {e}")
    except Exception as e:
        logger.error(f"Erreur inattendue lors du parsing: {e}")

    return vulnerabilities


def parse_vulners_output(output: str, port: str, service: str, version: str) -> List[Dict]:
    """
    Parse la sortie du script Vulners

    Format typique:
    CVE-2021-3156    10.0    Sudo vulnerability
    CVE-2019-15666   7.5     HTTP vulnerability
    """
    vulnerabilities = []

    lines = output.strip().split('\n')
    for line in lines:
        line = line.strip()
        if not line or line.startswith('[') or line.startswith('|'):
            continue

        # Rechercher les CVE
        if 'CVE-' in line or 'EXPLOITPACK:' in line or 'EDB-ID:' in line:
            parts = line.split()
            if len(parts) >= 2:
                cve_id = parts[0].strip()

                # Essayer d'extraire le score CVSS
                cvss_score = None
                description = ' '.join(parts[1:])

                # Si le deuxi√®me √©l√©ment est un nombre, c'est le score
                try:
                    cvss_score = float(parts[1])
                    description = ' '.join(parts[2:]) if len(parts) > 2 else ''
                except ValueError:
                    pass

                # D√©terminer la criticit√©
                severity = get_severity_from_cvss(cvss_score)

                vulnerabilities.append({
                    'cve_id': cve_id,
                    'cvss_score': cvss_score,
                    'severity': severity,
                    'description': description.strip() if description else f"Vuln√©rabilit√© d√©tect√©e sur {service}",
                    'port': port,
                    'service': service,
                    'version': version,
                    'source': 'vulners'
                })

    # Filtrer et limiter les vuln√©rabilit√©s
    # Garder uniquement CRITIQUE et √âLEV√â si il y en a beaucoup
    if len(vulnerabilities) > 10:
        critical_high = [v for v in vulnerabilities if v['severity'] in ['CRITIQUE', '√âLEV√â']]
        if len(critical_high) >= 5:
            vulnerabilities = critical_high

    # Trier par criticit√© et score
    severity_order = {'CRITIQUE': 0, '√âLEV√â': 1, 'MOYEN': 2, 'FAIBLE': 3, 'INCONNU': 4}
    vulnerabilities.sort(key=lambda x: (severity_order.get(x['severity'], 5), -(x['cvss_score'] or 0)))

    # Limiter √† 5 CVEs maximum par port
    return vulnerabilities[:5]


def parse_vuln_script_output(script_id: str, output: str, port: str, service: str) -> Optional[Dict]:
    """
    Parse la sortie des scripts vuln-*

    Ces scripts retournent g√©n√©ralement:
    VULNERABLE:
    Title: ...
    Description: ...
    """
    if 'VULNERABLE' not in output.upper() and 'LIKELY VULNERABLE' not in output.upper():
        return None

    # Extraire le titre
    title = script_id.replace('-', ' ').replace('_', ' ').title()

    # Essayer d'extraire plus d'infos
    lines = output.strip().split('\n')
    description_lines = []
    cve_ids = []

    for line in lines:
        line = line.strip()
        if 'CVE-' in line:
            # Extraire les CVE IDs
            import re
            cves = re.findall(r'CVE-\d{4}-\d{4,7}', line)
            cve_ids.extend(cves)

        if line and not line.startswith('|'):
            description_lines.append(line)

    description = ' '.join(description_lines[:3]) if description_lines else output[:200]
    cve_id = cve_ids[0] if cve_ids else script_id.upper()

    return {
        'cve_id': cve_id,
        'cvss_score': 7.5,  # Score par d√©faut pour les vuln√©rabilit√©s d√©tect√©es par scripts
        'severity': '√âLEV√â',
        'description': description.strip(),
        'port': port,
        'service': service,
        'version': '',
        'source': script_id
    }


def get_severity_from_cvss(cvss_score: Optional[float]) -> str:
    """
    D√©termine la criticit√© √† partir du score CVSS

    Args:
        cvss_score: Score CVSS (0.0-10.0)

    Returns:
        Niveau de criticit√©
    """
    if cvss_score is None:
        return 'INCONNU'

    if cvss_score >= 9.0:
        return 'CRITIQUE'
    elif cvss_score >= 7.0:
        return '√âLEV√â'
    elif cvss_score >= 4.0:
        return 'MOYEN'
    else:
        return 'FAIBLE'


def deduplicate_vulnerabilities(vulnerabilities: List[Dict]) -> List[Dict]:
    """
    D√©duplique les vuln√©rabilit√©s (m√™me CVE sur m√™me port)
    et limite le nombre total pour un affichage optimal

    Args:
        vulnerabilities: Liste de vuln√©rabilit√©s

    Returns:
        Liste d√©dupliqu√©e et filtr√©e
    """
    seen = set()
    unique_vulns = []

    for vuln in vulnerabilities:
        key = (vuln['cve_id'], vuln['port'])
        if key not in seen:
            seen.add(key)
            unique_vulns.append(vuln)

    # Trier par criticit√© (CRITIQUE > √âLEV√â > MOYEN > FAIBLE)
    severity_order = {'CRITIQUE': 0, '√âLEV√â': 1, 'MOYEN': 2, 'FAIBLE': 3, 'INCONNU': 4}
    unique_vulns.sort(key=lambda x: (severity_order.get(x['severity'], 5), -(x['cvss_score'] or 0)))

    # Limiter intelligemment si trop de vuln√©rabilit√©s
    if len(unique_vulns) > 30:
        # Garder toutes les CRITIQUES
        critical = [v for v in unique_vulns if v['severity'] == 'CRITIQUE']
        # Garder les 15 √âLEV√âES les plus importantes
        high = [v for v in unique_vulns if v['severity'] == '√âLEV√â'][:15]
        # Garder 5 MOYENNES
        medium = [v for v in unique_vulns if v['severity'] == 'MOYEN'][:5]

        unique_vulns = critical + high + medium

    return unique_vulns


def format_vulnerabilities_summary(vulnerabilities: List[Dict]) -> str:
    """
    Formate un r√©sum√© des vuln√©rabilit√©s pour l'affichage

    Args:
        vulnerabilities: Liste de vuln√©rabilit√©s

    Returns:
        R√©sum√© format√©
    """
    if not vulnerabilities:
        return "Aucune"

    total = len(vulnerabilities)

    # Compter par criticit√©
    critical = sum(1 for v in vulnerabilities if v['severity'] == 'CRITIQUE')
    high = sum(1 for v in vulnerabilities if v['severity'] == '√âLEV√â')
    medium = sum(1 for v in vulnerabilities if v['severity'] == 'MOYEN')

    parts = [f"Total: {total}"]

    if critical > 0:
        parts.append(f"üî¥ {critical}")
    if high > 0:
        parts.append(f"üü† {high}")
    if medium > 0:
        parts.append(f"üü° {medium}")

    return ' | '.join(parts)


def install_nmap_scripts():
    """
    Instructions pour installer les scripts Nmap NSE suppl√©mentaires
    """
    instructions = """
    INSTALLATION DES SCRIPTS NMAP NSE POUR VULN√âRABILIT√âS
    ======================================================

    1. Script Vulners (recommand√©):
       cd /usr/share/nmap/scripts/
       sudo wget https://raw.githubusercontent.com/vulnersCom/nmap-vulners/master/vulners.nse
       sudo nmap --script-updatedb

    2. Script Vulscan (base de donn√©es locale):
       cd /usr/share/nmap/scripts/
       sudo git clone https://github.com/scipag/vulscan.git
       sudo nmap --script-updatedb

    3. V√©rifier l'installation:
       nmap --script-help vulners
       nmap --script-help vulscan

    4. Scripts vuln int√©gr√©s (d√©j√† disponibles):
       nmap --script-help vuln

    USAGE:
    ------
    Le scanner utilisera automatiquement ces scripts s'ils sont install√©s.
    """

    return instructions
